"""Runtime Loom write-back helpers.

Automates append-only updates to `.loom` coordination files so that
non-trivial operations can persist ART/CLAIM/ORACLE (and SCAR) entries
without manual editing.
"""

from __future__ import annotations

import re
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Optional


@dataclass
class WritebackPacket:
    """Minimal write-back payload.

    Args:
        artifact_name: Artifact display name.
        artifact_type: Artifact type (code|doc|config|test|spec).
        artifact_path: Workspace-relative path.
        claim_statement: Bounded claim statement.
        claim_scope: local|module|system.
        claim_confidence: Confidence in range [0.0, 1.0].
        claim_falsifies: Falsification criterion.
        oracle_name: Oracle display name.
        oracle_method: test|manual-check|consistency-check|benchmark.
        oracle_command: Validation command.
        oracle_expected: Passing expectation text.
        scar: Optional failure/learning summary.
        boon: Optional coherence gain.
        newrule: Optional preventive rule.
        glyphstamp: Optional symbolic stamp.
    """

    artifact_name: str
    artifact_type: str
    artifact_path: str
    claim_statement: str
    claim_scope: str
    claim_confidence: float
    claim_falsifies: str
    oracle_name: str
    oracle_method: str
    oracle_command: str
    oracle_expected: str
    scar: str = ""
    boon: str = ""
    newrule: str = ""
    glyphstamp: str = ""


class LoomWriteback:
    """Append-only writer for `.loom` coordination files."""

    def __init__(self, workspace_root: str):
        self.root = Path(workspace_root)
        self.loom_dir = self.root / ".loom"
        self.artifact_file = self.loom_dir / "artifact-registry.md"
        self.claim_file = self.loom_dir / "claim-ledger.md"
        self.oracle_file = self.loom_dir / "oracle-matrix.md"
        self.wisdom_file = self.loom_dir / "trace-wisdom-log.md"

    def append_minimum(self, packet: WritebackPacket, owner: str = "runtime") -> dict[str, str]:
        """Append required write-back entries and return created IDs."""
        if not self.loom_dir.exists():
            raise FileNotFoundError(".loom directory not found")

        date_str = datetime.now().date().isoformat()

        art_id = self._append_artifact(
            name=packet.artifact_name,
            artifact_type=packet.artifact_type,
            artifact_path=packet.artifact_path,
            owner=owner,
            date=date_str,
        )

        claim_id = self._append_claim(
            statement=packet.claim_statement,
            scope=packet.claim_scope,
            confidence=packet.claim_confidence,
            falsifies=packet.claim_falsifies,
            source=art_id,
            date=date_str,
        )

        oracle_id = self._append_oracle(
            name=packet.oracle_name,
            verifies=claim_id,
            method=packet.oracle_method,
            command=packet.oracle_command,
            expected=packet.oracle_expected,
            date=date_str,
        )

        scar_id: Optional[str] = None
        if packet.scar or packet.boon:
            scar_id = self._append_scar(
                scar=packet.scar or "Runtime friction observed.",
                boon=packet.boon or "Improved process reliability.",
                newrule=packet.newrule,
                glyphstamp=packet.glyphstamp or "runtime-writeback",
                date=date_str,
            )

        result = {
            "artifact_id": art_id,
            "claim_id": claim_id,
            "oracle_id": oracle_id,
        }
        if scar_id:
            result["scar_id"] = scar_id
        return result

    def _append_artifact(
        self,
        name: str,
        artifact_type: str,
        artifact_path: str,
        owner: str,
        date: str,
    ) -> str:
        art_id = self._next_id(self.artifact_file, "ART")
        block = (
            f"\n{art_id}: {name}\n"
            f"  type: {artifact_type}\n"
            f"  path: {artifact_path}\n"
            f"  owner: {owner}\n"
            f"  created: {date}\n"
            f"  status: active\n"
            f"  notes: Auto-generated by runtime write-back.\n"
        )
        self._append_block(self.artifact_file, block)
        return art_id

    def _append_claim(
        self,
        statement: str,
        scope: str,
        confidence: float,
        falsifies: str,
        source: str,
        date: str,
    ) -> str:
        if not 0.0 <= confidence <= 1.0:
            raise ValueError(
                f"Invalid claim_confidence {confidence}: must be 0.0-1.0"
            )

        claim_id = self._next_id(self.claim_file, "CLAIM")
        block = (
            f"\n{claim_id}: \"{statement}\"\n"
            f"  scope: {scope}\n"
            f"  confidence: {confidence:.2f}\n"
            f"  falsifies: \"{falsifies}\"\n"
            f"  status: active\n"
            f"  source: {source}\n"
            f"  date: {date}\n"
        )
        self._append_block(self.claim_file, block)
        return claim_id

    def _append_oracle(
        self,
        name: str,
        verifies: str,
        method: str,
        command: str,
        expected: str,
        date: str,
    ) -> str:
        oracle_id = self._next_id(self.oracle_file, "ORACLE")
        block = (
            f"\n{oracle_id}: {name}\n"
            f"  verifies: {verifies}\n"
            f"  method: {method}\n"
            f"  command: {command}\n"
            f"  expected: {expected}\n"
            f"  last_run: {date}\n"
            f"  result: pass\n"
            f"  notes: Auto-generated by runtime write-back.\n"
        )
        self._append_block(self.oracle_file, block)
        return oracle_id

    def _append_scar(
        self,
        scar: str,
        boon: str,
        newrule: str,
        glyphstamp: str,
        date: str,
    ) -> str:
        scar_id = self._next_id(self.wisdom_file, "SCAR")
        rule_line = f"\n  newrule: \"{newrule}\"" if newrule else ""
        block = (
            f"\n- id: {scar_id}\n"
            f"  scar: \"{scar}\"\n"
            f"  boon: \"{boon}\""
            f"{rule_line}\n"
            f"  glyphstamp: \"{glyphstamp}\"\n"
            f"  date: {date}\n"
        )
        self._append_block(self.wisdom_file, block)
        return scar_id

    def _next_id(self, file_path: Path, prefix: str) -> str:
        text = file_path.read_text(encoding="utf-8") if file_path.exists() else ""
        pattern = re.compile(rf"\b{prefix}-(\d{{3}})\b")
        ids = [int(m.group(1)) for m in pattern.finditer(text)]
        next_num = (max(ids) + 1) if ids else 1
        return f"{prefix}-{next_num:03d}"

    def _append_block(self, file_path: Path, block: str) -> None:
        if not file_path.exists():
            raise FileNotFoundError(f"Missing loom file: {file_path}")
        with file_path.open("a", encoding="utf-8") as f:
            f.write(block)
